{
  "version": 3,
  "sources": ["../../hooks/hooks.js"],
  "sourcesContent": ["// TODO Add in pre and post skipping options\nmodule.exports = {\n  /**\n   *  Declares a new hook to which you can add pres and posts\n   *  @param {String} name of the function\n   *  @param {Function} the method\n   *  @param {Function} the error handler callback\n   */\n  hook: function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === 'object') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === 'function'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error(\"Your pre must have next and done arguments -- e.g., function (next, done, ...)\");\n              if (currPre.length < 1)\n                throw new Error(\"Your pre must have a next argument -- e.g., function (next, ...)\");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!proto[name].numAsyncPres) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error(\"Your post must have a next argument -- e.g., function (next, ...)\");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === 'function'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === 'function'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n      if (_asyncsLeft) {\n        function _asyncsDone (err) {\n          if (err && err instanceof Error) {\n            return handleError(err);\n          }\n          --_asyncsLeft || _done.apply(self, hookArgs);\n        }\n      }\n      function handleError (err) {\n        if ('function' == typeof lastArg)\n          return lastArg(err);\n        if (errorCb) return errorCb.call(self, err);\n        throw err;\n      }\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  },\n\n  pre: function (name, isAsync, fn, errorCb) {\n    if ('boolean' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  },\n  post: function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  },\n  removePre: function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  },\n  _lazySetupHooks: function (proto, methodName, errorCb) {\n    if ('undefined' === typeof proto[methodName].numAsyncPres) {\n      this.hook(methodName, proto[methodName], errorCb);\n    }\n  }\n};\n\nfunction once (fn, scope) {\n  return function fnWrapper () {\n    if (fnWrapper.hookCalled) return;\n    fnWrapper.hookCalled = true;\n    return fn.apply(scope, arguments);\n  };\n}\n"],
  "mappings": "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",
  "names": ["pres", "posts", "args_", "postArgs", "_asyncsDone"]
}
